---
title: 5种提升自动化回归测试性能的技巧
sourceTitle: 5 Tricks to elevate your automated regression tests
source: https://medium.com/swlh/5-tricks-to-elevate-your-automated-regression-tests-762f437c55e6
image: https://evernotepic-1253152250.cos.ap-shanghai.myqcloud.com//20191023155334.png
---

<!-- ![](https://evernotepic-1253152250.cos.ap-shanghai.myqcloud.com//20191023155334.png) -->

> 您是否注意到过您的自动回归测试不稳定并且经常失败？
> 您和您团队的其他成员是否不再信任自动回归测试的结果？
> 当您的 App 更改时，您是否很难更换测试？

面对以上问题不用担心，我们在这里整理了一些关键的实践经验，可以帮助您进行更灵活的测试。让我们开始吧！

## 使用测试专用的 Selector

大部分自动测试失效的原因都是由于你或者团队中的其它人重新编辑了用于自动测试的元素（element）。
解决这个问题的方法是在 HTML 和自动化测试中使用测试专用的标识符。当这个标识符添加到代码中后，测试便可以不再依赖和使用原代码中已经存在的`id`或者`class`，从而避免了未来可能发生的测试冲突。
为了让这个方法起作用，你还需要在团队成员间对使用什么样的测试标识符达成共识。  
![](https://evernotepic-1253152250.cos.ap-shanghai.myqcloud.com//20191023160605.png)
例如，在 HTML 中，你已经向所有人清楚标识了自动化测试将会使用该元素。其中`qaid`代表该标识符是用于测试用途：

```js
let testDOM = document.querySelector('a[data-qaid="shop-ankle-boots"]');
```

> 使用`data-*`作为标识符能够保证该属性的内容不会显示在页面中（会被页面解析器忽略）或者在 JS 中被意外引用。因此这里建议所有的测试属性都使用`data-`前缀，关于这个 H5 的新属性更多的可以点击(使用数据属性)[https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Using_data_attributes]了解。

## 独立地自动化单个流程

我们都知道，应当保证每个自动化测试不依赖于先前测试的输出或先前测试中创建的数据，使每个测试之间彼此独立有助于确保测试的结果无论在怎样的执行顺序下都是相同的。
这种独立性带来的另一个好处是保证了测试在单独运行和共同运行时的结果一致。从而使你能够更轻松的将测试组合到不同的套件中，以促进测试的重用。关于测试隔离原则可以查看(单元测试的 F.I.R.S.T.原则)[https://github.com/ghsukumar/SFDC_Best_Practices/wiki/F.I.R.S.T-Principles-of-Unit-Testing#isolatedindependent]

## DRY 原则（Don't Repeat Yourself）

When you’re writing automated tests and see that you are repeating the same set of steps in more than three places or so, it’s time to start thinking of ways to minimize the duplication of code that you’re writing.
For instance, if there is a repeatable set of steps that you often use in your code that isn’t part of your test framework API, create a reusable function that contains these steps and import it into your test file.
If there is a statement that is repeated more than once, then you should consider putting the repeated code into a reusable function. This helps with the overall maintainability of your code in addition to assisting with readability.
当编写自动化测试时发现要在三个以上的地方重复同一组步骤时，那就是时候开始考虑最大程度地减少编写重复代码的方法了。
例如，如果你经常在代码中使用重复的步骤组合，而这些步骤却不属于测试框架 API，那么可以创建包含这些步骤的函数来实现可重用性，并将其导入到测试文件中；如果有语句多次重复的，则应考虑将重复的代码放入可重用的函数中。除了提高可读性之外，这还有助于代码的整体可维护性。

> 但你在写代码过程中可以不必过分担心写出不够 DRY 的代码，可以在提交代码之前再考虑将其重写为 DRY 的代码。

以下面的代码段为例：
```js
printAccountBalance(account);
{
  if (account.fees < 0) {
    console.log(`Fees: -$${account.fees}`);
  } else {
    console.log(`Fees: $${account.fees}`);
  }
  if (account.balance < 0) {
    console.log(`Balance: -$${account.balance}`);
  } else {
    console.log(`Balance: ${account.balance}`);
  }
}
```

This code snippet can be simplified into something that’s easier to read if we move the formatting of the currency over to a different function.
以上代码主要是调整了货币格式并输出，因此我们如果为货币格式转换这一功能创建一个可重用的函数，则代码段会变得更加易读：
```js
// 货币格式转换
formatAmount(dollarAmount);
{
  const formatter = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD"
  });
  return formatter.format(dollarAmount);
}
printAccountBalance(account);
{
  console.log("Debits", formatAmount(account.debits));
  console.log("Fees", formatAmount(account.debits));
}
```
如你所见，我们删除了所有的`if`语句，使代码的整体可读性和可维护性都变好了。

DRY概念在软件领域非常的常见，如果时间允许我们甚至可以谈几个小时，但如果你对这个概念有兴趣，可以点击(更多)[https://blog.csdn.net/flysnowjava/article/details/80604291]了解。

## No Explicit Waits

When automating an asynchronous application, sometimes it is necessary to wait for a certain amount of time in order for some actions to complete. We’ve found that waiting for a set number of times can introduce flakiness in the tests as the item may not appear in the time that was set or it may appear before the timeout period that was specified. As a result, your tests will unnecessarily wait longer.

```js
await setSignIn(userName, password);
const waitTime = 10000;
await t.wait(waitTime);
await t.click(provinceDropDownList.withText(provinceCode));
await setSignIn(userName, password);
const waitTime = 60000;
await t.expect(isSignedInConfirmation.exists).ok({ timeout: waitTime });
await t.click(provinceDropDownList.withText(provinceCode));
```

If waiting for an arbitrary amount of time is necessary in many places, create a polling method to check for the appearance of the item that you would like to see so that you can reuse the same method multiple times.
waitForSelector(selector, number = 1000) { await t.expect(selector.exists).ok({ timeout: waitTime }); }

> The automation code examples used here are written TestCafe, but the principles we’re talking about can be applied to any test framework.

## Code Organization

Organize your code in a way that allows everyone to quickly find where things are located relative to the items that are being tested. The names of Files, Variables and Functions should be clear and describe the intent that the item is needed to perform.
The naming of things is really important because they help everyone to understand the function as well as helping with the maintenance of your code. Properly naming things helps everyone to understand the intent of the work that you were trying to perform without diving into any particular function.
When choosing a name for a method, pick a particular verb and use the same verb to refer to the same set of actions throughout your code. For example, use Get for methods that are used to get values and Set as the beginning prefix for methods that are used to update a particular variable.

```js
setNewUserName(oldUsername,newUsername) { } 
changeUserLocation(oldUsername,newUsername) { }
```

When there is no consistent naming pattern in the code, it’s harder to maintain and you or your maintainers will not be able to see at a glance what the code modifies.

```js
setNewUserName(oldUsername,newUsername) { } 
setUserLocation(oldUsername,newUsername) { }
```

Adopting one of the many test design patterns such as Page Object Model, Factory or Facade can be help contribute to the maintainability of automated tests. If you’d like to dive deeper into code organization, Clean Code is a good place to start.

> Testing design patterns that move the complexity of your tests into another facade and out of the tests are beneficial in ensuring that you won’t need to maintain the actual tests themselves and only the underlying facade. This insulates your tests and makes them more useable.

```js
class ContactUS {
  openGetHelpModal() {
    click(getHelpModal);
  }
  closeGetHelpModal() {
    click(this.closeHelpModal);
  }
}
```

## Automate One Browser First

Focusing on one browser in the beginning will allow you to put an emphasis on writing your first suite of tests. Usually, we try to first make sure that the underlying business logic works properly and that the tests are run reliably before we introduce complexity by adding more browsers.
For the vast majority of functional cases when a test works in one browser, it should work in others. With this in mind, you should start to focus your attention on one browser first.
Get the analytics for the most used browser on your application and use that browser as the candidate for your automation efforts.

> If browser compatibility tests are needed for your application, select a subset of your tests that perform the actions that may break on different browsers and only run those tests on all browsers. This will help to reduce the run time of tests so that you can get results faster.

## In closing

These tricks are beneficial in helping to reduce the flakiness in the automated regression tests and can assist you and your team in moving to a place where you can put more trust in them. Adopting these tricks will help you to increase reliability so that your team can put increased trust in the outcome of your automated regression tests.
